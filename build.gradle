apply plugin: 'java-library'
apply plugin: 'eclipse'

buildscript {
	dependencies {
		classpath "nu.studer:gradle-credentials-plugin:2.1"
		classpath "net.saliman:gradle-properties-plugin:1.5.1"
		classpath "org.ajoberstar.grgit:grgit-gradle:4.1.0"
	}

	repositories {
		mavenLocal()
		mavenCentral()

		maven {
			url "https://repository-cdn.liferay.com/nexus/content/groups/public"
		}
	}
}

apply from: "build-nexus.gradle"

allprojects {
	group = "it.smc.marketplace.caldav-sync"
}

def productBoms = []
String boms = properties["product.bill.of.meterials"]

if (boms != null) {
	productBoms = boms.split(",")

	// Create Distribution Profile (configuration) for BoMs
	configurations {
		distBOM {
			transitive = false
			visible = false
		}
	}

	if (productBoms.size() > 0) {
		dependencies {
			productBoms.each {
				String[] parts = it.split(":")
				distBOM("${it}") {
					artifact {
						name = parts[1]
						type = "pom"
					}
				}
			}
		}
	}
}

def isChangedProject = {
	ext.changedProjects.contains(it) ? true : false
}

gradle.beforeProject {
	Project project ->

	// Skip root and projects with childs
	if (!project.parent || project.childProjects) {
		return
	}

	// Skip BoM project and Plugins SDK
	if (project.path.equals(":bom") || project.path.startsWith(":plugins-sdk")) {
		return
	}

	configure(project) {

		// Add Nexus upload tasks (for binary and sources) and other
		// useful elements or tasks

		def managedType = ""

		if (project.tasks.findByName("war")) {
			if (project.path.startsWith(":wars:")) {
				managedType = "war"
			}

			task packageForDist(dependsOn: war) {
				// Empty. Only needed for task dependencies
			}

		}
		else if (project.tasks.findByName("jar")) {
			managedType = "jar"

			task packageForDist(dependsOn: jar) {
				// Empty. Only needed for task dependencies
			}

			task releaseIncrementMajor() {
				doLast {
					_updateBndBundleVersion(project, 1)
				}
			}

			task releaseIncrementMinor() {
				doLast {
					_updateBndBundleVersion(project, 2)
				}
			}

			task releaseIncrementMicro() {
				doLast {
					_updateBndBundleVersion(project, 3)
				}
			}
		}

		if (managedType.equals("war") || managedType.equals("jar")) {
			//println "ext=${managedType}"

			// Force encoding (for portability)
			compileJava.options.encoding = 'UTF-8'

			task sourcesJar(type: Jar, dependsOn:classes) {
				classifier = 'sources'
				from sourceSets.main.allSource
			}

			dependencies {
				/* No more needed
				// We have to force version because Liferay BOMs have conflicting versions
				compileOnly("javax.servlet:javax.servlet-api:3.0.1") { force = true }
				*/
				if (productBoms.size() > 0) {
					productBoms.each {
						compileOnly platform("${it}")
					}
				}
			}

			// Set real artifact version

			if (!project.hasProperty("version")) {
				throw new GradleException("No available property 'version'")
			}

			def finalVersion = project.property('version')
			ext.originalVersion = finalVersion

			if (finalVersion.endsWith("-SNAPSHOT")) {
				println "WARNING: Project with explicit SNAPSHOT version ${project.path} ${project.property('version')}"
			}

			if (!finalVersion.endsWith(project.property('registrySuffix'))) {
				finalVersion = "${project.property('version')}${project.property('registrySuffix')}"
				logger.debug("SMC ${project.path} change version ${project.property('version')} to ${finalVersion}")
				project['version'] = finalVersion
				logger.debug("SMC check ${project.property('version')} ")
			}

			def nexusRepository = project.property('nexus.snapshots.url')

			if (!finalVersion.endsWith("-SNAPSHOT")) {
				nexusRepository = project.property('nexus.releases.url');
			}

			project.plugins.withId('maven-publish') {
				publishing {
					publications {
						if (managedType.equals("war")) {
							mavenJava(MavenPublication) {
								version = "${finalVersion}"
								artifactId = project.property('archivesBaseName')
								from components.web
								artifact(tasks["sourcesJar"])
							}
						}
						else {
							mavenJava(MavenPublication) {
								version = "${finalVersion}"
								artifactId = project.property('archivesBaseName')
								from components.java
								artifact(tasks["sourcesJar"])
							}
						}
					}
					repositories {
						maven {
							url = nexusRepository
							credentials {
								username project.property('registryUsername')
								password project.property('registryPassword')
							}
						}
					}
				}

				task showPublishDetails() {
					def msg =
						"${project.property('group')}:${project.property('archivesBaseName')}:${project.property('version')}" +
						" (suffix ${project.property('registrySuffix')})" +
						" on ${nexusRepository} as ${project.property('registryUsername')}"

					doLast {
						println "Published ${msg}"
					}
				}

				publish.dependsOn(showPublishDetails);

				publishToMavenLocal.dependsOn(showPublishDetails)
			}

		}
	}

}

private void _updateBndBundleVersion(Project project, int level) {
	def bndFile = project.file("bnd.bnd")

	if (!bndFile.exists()) {
		println "WARNING: No bnd.bnd for ${project.path}"
	}
	else {
		def bndContent = bndFile as String[]

		def curVersions = project.property('version').tokenize(".")

		if (curVersions.size() != 3) {
			println "WARNING: Non standard version ${moduleVersion} for ${project.path}"
		}
		
		def curMicros = curVersions[2].tokenize("-")

		def newMajor = curVersions[0].toInteger()
		def newMinor = curVersions[1].toInteger()
		def newMicro = curMicros[0].toInteger()

		if (level == 3) {
			newMicro++
		}
		else if (level == 2) {
			newMinor++
			newMicro = 0
		}
		else if (level == 1) {
			newMajor++
			newMinor = 0
			newMicro = 0
		}
		else {
			throw new GradleException("Invalid level ${level}")
		}

		def newVersion = "${newMajor}.${newMinor}.${newMicro}"

		bndFile.withWriter('UTF-8') { writer ->
			bndContent.each {
				if (it.indexOf("Bundle-Version") == 0) {
					writer.writeLine "Bundle-Version: ${newVersion}"
				}
				else {
					writer.writeLine it
				}
			}
		}

		println "${project.path} = ${project.property('version')} -> ${newVersion}"
	}
}

/*
 ***************************
 *  Distribution Profiles  *
 ***************************
 */

apply from: "build-dist.gradle"

// Apply custom BoMs to all the notable configurations
//
configurations.each { config ->
	if (config.name.equals("targetPlatformBoms")) {
		if (productBoms.size() > 0) {
			productBoms.each {
				config.dependencies.add(dependencies.platform("${it}"))
			}
		}
	}
	else if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
		return;
	}

	if (productBoms.size() > 0) {
		productBoms.each {
			config.dependencies.add(dependencies.platform("${it}"))
		}
	}
}


def getTimeStampStr() {
	new Date().format('yyyyMMddHHmmss')
}

def localBundleDir = project.properties['liferay.workspace.home.dir']
ext.productVersion = project.properties['product.version'] ?: "1.0.0"
ext.productName = project.properties['product.name'] ?: project.name

String distLocalMode = project.properties["distLocalMode"]

if (distLocalMode == null && project.properties['nexus.release.mode'] == "true") {
	distLocalMode = "false"
}
else if (distLocalMode == null && project.properties['gitSnapshotsBranch'] == false) {
	distLocalMode = "false"
}
else if (distLocalMode == null) {
	distLocalMode = "true"
}

println "** distLocalMode = ${distLocalMode}"

/*
 * List all workspace projects with artifact name and including profiles
 */
task listProjects() {
	doLast {
		def resultMap = [:]
		int pathSize = 0
		int refSize = 0

		rootProject.subprojects.each { prj ->
			if (!prj.subprojects.empty) return
			if (prj.path.equals(":bom") || prj.path.startsWith(":plugins-sdk")) return

			def prjRef = "${prj.group}:${prj.property('archivesBaseName')}:${prj.version}"

			pathSize = Math.max(pathSize, prj.path.size())
			refSize = Math.max(refSize, prjRef.size())

			resultMap[prj.path] = [ ref : prjRef, configs : [] ]
		}

		configurations.each { config ->
			if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
				return;
			}

			config.getDependencies().each{ dep ->
				if (dep instanceof ProjectDependency) {
					ProjectDependency projectDependency = dep as ProjectDependency

					Project depPrj = projectDependency.getDependencyProject()

					resultMap[depPrj.path].configs.add(config.name)
				}
			}
		}

		def noConfigs = []

		resultMap.sort().each{ entry ->
			println "${entry.key.padRight(pathSize)}\t${entry.value.ref.padRight(refSize)}\t${entry.value.configs}"

			if (entry.value.configs.size() == 0) {
				noConfigs.add(entry.key);
			}
		}

		if (noConfigs.size() > 0) {
			println ""
			println "Projects without Distribution Profile"

			noConfigs.each{ println it }
		}
	}
}

/*
 * List all configurations eligible as "Distribution Profile"
 */
task listDistProfiles() {
	doLast {
		configurations.each { config ->
			if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
				return;
			}

			def taskName = config.name.capitalize()
			println config.name + " ->  tar$taskName , zip$taskName , deploy$taskName"
		}
	}
}

/*
 * Describe "Distribution Profile" in a way usable in build-dist.gradle
 * as dependency
 * TODO: Find a way to resolve bom versions
 */
task showDistProfiles() {
	if (distLocalMode == "true") {
		dependsOn configurations.archives.artifacts
	}

	doLast {
		configurations.each { config ->
			if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
				return;
			}

			println "----"
			println "Distribution Profile: ${archivesBaseName}-${productVersion} ${config.name} ${project.property('registrySuffix')}"
			println ""
			println "dependencies {"

			def values = []

			config.getDependencies().each{ dep ->
				if (dep instanceof ExternalDependency) {
					ProjectDependency projectDependency = dep as ProjectDependency

					if (projectDependency.version != null) {
						values.add("compileOnly group:'${projectDependency.group}', name:'${projectDependency.name}', version:'${projectDependency.version}'")
					}
					else {
						values.add("compileOnly group:'${projectDependency.group}', name:'${projectDependency.name}'")
					}
				}
				else if (dep instanceof ProjectDependency) {
					ProjectDependency projectDependency = dep as ProjectDependency

					Project prj = projectDependency.getDependencyProject()

					String archivesBaseName = prj.properties["archivesBaseName"]
					String targetVersion = projectDependency.version

					if (!isChangedProject(prj.path) && prj.hasProperty('originalVersion')) {
						targetVersion = prj.property('originalVersion')
					}

					values.add("compileOnly group:'${projectDependency.group}', name:'${archivesBaseName}', version:'${targetVersion}'")
				}
				else {
					println "	//??? ${dep}"
				}
			}

			values.sort().each{ println "	${it}"}

			println "}"
			println ""
		}
	}
}

/*
 * Describe "Distribution Profile" in a way usable to materialize a
 * local maven repository
 */
task showDistInstall() {
	if (distLocalMode == "true") {
		dependsOn configurations.archives.artifacts
	}

	doLast {
		configurations.each { config ->
			if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
				return;
			}

			println "----"
			println "Distribution Profile: ${productName}-${productVersion} ${config.name} ${project.property('registrySuffix')}"
			println ""

			def values = []
			def resolved = config.getResolvedConfiguration();

			resolved.getLenientConfiguration().getFirstLevelModuleDependencies().each{ dep ->
				//println dep

				if (dep.configuration.equals("platform-runtime")) {
					return //continue
				}

				String packaging = "jar"

				dep.moduleArtifacts.any{ ma ->
					packaging = ma.extension

					return true //break
				}

				values.add("mvn install:install-file -Dfile='libs/${dep.moduleName}-${dep.moduleVersion}.${packaging}' -DgroupId='${dep.moduleGroup}' -DartifactId='${dep.moduleName}' -Dversion='${dep.moduleVersion}' -Dpackaging=${packaging}")
			}

			values.sort().each{ println "${it}"}

			println ""
		}
	}
}

/*
 * This task is useful on local developer environment to deploy project
 * core element on local Liferay.
 */
task deployCoreDependencies(type: Copy) {
	into "${localBundleDir}/deploy"
	from configurations.distCoreLibs
}

def tarProfiles = []
def zipProfiles = []

def distDependencySpec(boolean allowExternal, boolean allowProject) {
	return new Spec<Dependency>() {
		boolean isSatisfiedBy(Dependency element) {
			if (element instanceof ExternalDependency && allowExternal) {
				return true
			}
			else if (element instanceof ProjectDependency && allowProject) {
				return true
			}
			else {
				return false
			}
		}
	}
}

task buildDistDepsMap() {
	doLast {
		configurations.each { config ->
			if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
				return;
			}

			Configuration clone = null;

			if (distLocalMode == "true" && project.properties['changesMode'] == false) {
				clone = config.copy()

				// Ensure clone has custom BoMs
				if (!config.name.equals("distBOM") && productBoms.size() > 0) {
					productBoms.each {
						clone.dependencies.add(dependencies.platform("${it}"))
					}
				}
			}
			else {
				clone = config.copy(distDependencySpec(true, false))

				// Ensure clone has custom BoMs
				if (!config.name.equals("distBOM") && productBoms.size() > 0) {
					productBoms.each {
						clone.dependencies.add(dependencies.platform("${it}"))
					}
				}

				config.dependencies.each { dep ->
					if (dep instanceof ExternalDependency) {
						// Already included
					}
					else if (dep instanceof ProjectDependency) {
						ProjectDependency projectDependency = dep as ProjectDependency

						Project prj = projectDependency.getDependencyProject()

						//println "DBG ${prj.path}:${prj.properties['version']}:${prj.properties['originalVersion']}"

						if (isChangedProject(prj.path) && distLocalMode == "true") {
							//println " has changes use local "
							clone.dependencies.add(projectDependency)
						}
						else {
							String archivesBaseName = prj.properties["archivesBaseName"]

							def moduleVersion = prj.properties['originalVersion'] ?: prj.properties['version']

							clone.dependencies.add(dependencies.create("${projectDependency.group}:${archivesBaseName}:${moduleVersion}"))
						}
					}
					else {
						println "??? ${dep}"
					}
				}
			}

			def taskName = config.name.capitalize()

			Task zipTargetTask = tasks.getByName("zip$taskName")

			zipTargetTask.into("libs") {
				from clone
			}

			Task tarTargetTask = tasks.getByName("tar$taskName")

			tarTargetTask.into("libs") {
				from clone
			}
		}
	}
}


configurations.each { config ->
	if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
		return;
	}

	//println config.name + ":" + config.visible

	def taskName = config.name.capitalize()

	tarProfiles.add("tar$taskName")
	zipProfiles.add("zip$taskName")

	task "tar$taskName"(type: Tar) {
		description = "Build a tarball of runtime artifacts"
		//archiveAppendix = config.name
		archiveBaseName = productName
		archiveClassifier = "${config.name}-${getTimeStampStr()}"
		archiveVersion = productVersion
		duplicatesStrategy = DuplicatesStrategy.EXCLUDE
		compression = Compression.GZIP

		dependsOn buildDistDepsMap
	}

	task "zip$taskName"(type: Zip) {
		description = "Build a zip of runtime artifacts"
		//archiveAppendix = config.name
		archiveBaseName = productName
		archiveClassifier = "${config.name}-${getTimeStampStr()}"
		archiveVersion = productVersion
		duplicatesStrategy = DuplicatesStrategy.EXCLUDE

		dependsOn buildDistDepsMap
	}

	task "deploy$taskName"(type: Copy) {
		description = "Deploy dependencies on local Liferay"

		Configuration clone = config.copy(distDependencySpec(true, false));

		config.getDependencies().each{ dep ->
			if (dep instanceof ProjectDependency) {
				ProjectDependency projectDependency = dep as ProjectDependency
				Project prj = projectDependency.getDependencyProject()

				dependsOn "${prj.path}:deploy"
			}
		}

		into "${localBundleDir}/deploy"
		from clone
	}

	Task tarTargetTask = tasks.getByName("tar$taskName")
	Task zipTargetTask = tasks.getByName("zip$taskName")

	//if (distLocalMode == "true" && project.properties['changesMode'] == true) {
	if (distLocalMode == "true") {
		config.dependencies.each { dep ->
			if (dep instanceof ProjectDependency) {
				ProjectDependency projectDependency = dep as ProjectDependency

				Project prj = projectDependency.getDependencyProject()

				if (project.properties['changesMode'] == true) {
					if (isChangedProject(prj.path)) {
						tarTargetTask.dependsOn(prj.path + ":packageForDist")
						zipTargetTask.dependsOn(prj.path + ":packageForDist")
					}
				}
				else {
					tarTargetTask.dependsOn(prj.path + ":packageForDist")
					zipTargetTask.dependsOn(prj.path + ":packageForDist")
				}
			}
		}
	}
}

task tarDistAll() {
	dependsOn tarProfiles
}

task zipDistAll() {
	dependsOn zipProfiles
}

/*
 * List projects which artifact isn't already published to Maven Repository
 */
task checkPubStatus() {

	doLast {
		def prjMap = [:]

		// Create a configuration with all the projects

		Configuration config = configurations.create("publicationStatus")

		config.transitive = false
		config.visible = false

		rootProject.subprojects.each { prj ->
			if (!prj.subprojects.empty) return
			if (prj.path.startsWith(":bom") || prj.path.startsWith(":plugins-sdk")) return

			String archivesBaseName = prj.properties["archivesBaseName"]
			String targetVersion = prj.properties["version"]

			if (!isChangedProject(prj.path) && prj.hasProperty('originalVersion')) {
				targetVersion = prj.property('originalVersion')
			}

			def prjId = "${prj.group}:${archivesBaseName}:${targetVersion}"

			logger.debug("SMC ${prj} : ${prjId}")

			config.dependencies.add(dependencies.create("${prjId}"))

			prjMap["${prjId}"] = prj
		}

		//deltaPublication.resolve()

		def resolved = config.getResolvedConfiguration()

		println "Has errors = ${resolved.hasError()}"

		// Show resolved modules with changes

		println "INFO: modules with changes (from last release-tag) but same version is already published"

		resolved.getLenientConfiguration().getFirstLevelModuleDependencies().each{ dep ->
			def prjId = "${dep.moduleGroup}:${dep.moduleName}:${dep.moduleVersion}"

			Project prj = prjMap["${prjId}"]

			if (prj != null) {
				if (isChangedProject(prj.path)) {
					logger.debug("SMC ${prjId} -> 	${prj.path}")
					println "	${prj.path}"
				}
			}
			else {
				println "	not found ${prjId}"
			}
		}

		println "ERROR: modules not published"

		resolved.getLenientConfiguration().getUnresolvedModuleDependencies().each{ dep ->
			def prjId = "${dep.selector.group}:${dep.selector.name}:${dep.selector.version}"

			Project prj = prjMap["${prjId}"]

			if (prj != null) {
				logger.debug("SMC ${prjId} -> 	${prj.path}")
				println "	${prj.path}"
			}
			else {
				println "	not found ${prjId}"
			}
		}

	}
}
