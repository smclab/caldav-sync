apply plugin: 'java-library'
apply plugin: 'eclipse'

buildscript {
	dependencies {
		classpath "nu.studer:gradle-credentials-plugin:2.1"
		classpath "net.saliman:gradle-properties-plugin:1.5.1"
		classpath "org.ajoberstar.grgit:grgit-gradle:4.1.1"
	}

	repositories {
		mavenLocal()
		mavenCentral()

		maven {
			url "https://repository-cdn.liferay.com/nexus/content/groups/public"
		}
	}
}

apply from: "build-nexus.gradle"

allprojects {
	group = "it.smc.marketplace.caldav-sync"
}

def productBoms = []
String boms = properties["product.bill.of.meterials"]

if (boms != null) {
	productBoms = boms.split(",")
}


def isChangedProject = {
	ext.changedProjects.contains(it) ? true : false
}


task listProjects() {
	doLast {
		rootProject.subprojects.each { prj ->
			if (!prj.subprojects.empty) return
			if (prj.path.equals(":bom") || prj.path.startsWith(":plugins-sdk")) return

			println "${prj.path}\t${prj.group}:${prj.property('archivesBaseName')}:${prj.version}"
		}
	}
}

gradle.beforeProject {
	Project project ->

	// Skip root and projects with childs
	if (!project.parent || project.childProjects) {
		return
	}

	// Skip BoM project and Plugins SDK
	if (project.path.equals(":bom") || project.path.startsWith(":plugins-sdk")) {
		return
	}

	configure(project) {

		// Add Nexus upload tasks (for binary and sources) and other
		// useful elements or tasks

		if (project.tasks.findByName("jar")) {
			task packageForDist(dependsOn: jar) {
				// Empty. Only needed for task dependencies
			}

			// Force encoding (for portability)
			compileJava.options.encoding = 'UTF-8'

			task sourcesJar(type: Jar, dependsOn:classes) {
				classifier = 'sources'
				from sourceSets.main.allSource
			}

			dependencies {
				// We have to force version because Liferay BOMs have conflicting versions
				compileOnly("javax.servlet:javax.servlet-api:3.0.1") { force = true }
			}

			task releaseIncrementMajor() {
				doLast {
					_updateBndBundleVersion(project, false)
				}
			}

			task releaseIncrementMinor() {
				doLast {
					_updateBndBundleVersion(project, true)
				}
			}

			// Set real artifact version

			def finalVersion = project.property('version')
			ext.originalVersion = finalVersion

			if (finalVersion.endsWith("-SNAPSHOT")) {
				println "WARNING: Project with explicit SNAPSHOT version ${project.path} ${project.property('version')}"
			}

			if (!finalVersion.endsWith(project.property('registrySuffix'))) {
				finalVersion = "${project.property('version')}${project.property('registrySuffix')}"
				logger.debug("SMC ${project.path} change version ${project.property('version')} to ${finalVersion}")
				project['version'] = finalVersion
				logger.debug("SMC check ${project.property('version')} ")
			}

			def nexusRepository = project.property('nexus.snapshots.url')

			if (!finalVersion.endsWith("-SNAPSHOT")) {
				nexusRepository = project.property('nexus.releases.url');
			}

			project.plugins.withId('maven-publish') {
				publishing {
					publications {
						mavenJava(MavenPublication) {
							version = "${finalVersion}"
							artifactId = project.property('archivesBaseName')
							from components.java
							artifact(tasks["sourcesJar"])
						}
					}
					repositories {
						maven {
							url = nexusRepository
							credentials {
								username project.property('registryUsername')
								password project.property('registryPassword')
							}
						}
					}
				}

				task showPublishDetails() {
					def msg =
						"${project.property('group')}:${project.property('archivesBaseName')}:${project.property('version')}" +
						" (suffix ${project.property('registrySuffix')})" +
						" on ${nexusRepository} as ${project.property('registryUsername')}"

					doLast {
						println "Published ${msg}"
					}
				}

				publish.dependsOn(showPublishDetails);

				publishToMavenLocal.dependsOn(showPublishDetails);
			}

		}
		else if (project.tasks.findByName("war")) {
			task packageForDist(dependsOn: war) {
				// Empty. Only needed for task dependencies
			}

			def finalVersion = project.property('version')
			ext.originalVersion = finalVersion

			// Force encoding (for portability)
			compileJava.options.encoding = 'UTF-8'
		}

	}

}

private void _updateBndBundleVersion(Project project, boolean minorMode) {
	def bndFile = project.file("bnd.bnd")

	if (!bndFile.exists()) {
		println "WARNING: No bnd.bnd for ${project.path}"
	}
	else {
		def bndContent = bndFile as String[]

		def curVersions = project.property('version').tokenize(".")

		if (curVersions.size() != 3) {
			println "WARNING: Non standard version ${moduleVersion} for ${project.path}"
		}

		def newMajor = curVersions[0].toInteger();
		def newMinor = curVersions[1].toInteger();

		if (minorMode) {
			newMinor++
		}
		else {
			newMajor++
			newMinor = 0
		}

		def newVersion = "${newMajor}.${newMinor}.0"

		bndFile.withWriter('UTF-8') { writer ->
			bndContent.each {
				if (it.indexOf("Bundle-Version") == 0) {
					writer.writeLine "Bundle-Version: ${newVersion}"
				}
				else {
					writer.writeLine it
				}
			}
		}

		println "${project.path} = ${project.property('version')} -> ${newVersion}"
	}
}

/*
 ***************************
 *  Distribution Profiles  *
 ***************************
 */

apply from: "build-dist.gradle"

// Apply custom BoMs to all the notable configurations
//
configurations.each { config ->
	if (config.name.equals("targetPlatformBoms")) {
		if (productBoms.size() > 0) {
			productBoms.each {
				config.dependencies.add(dependencies.platform("${it}"))
			}
		}
	}
	else if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
		return;
	}

	if (productBoms.size() > 0) {
		productBoms.each {
			config.dependencies.add(dependencies.platform("${it}"))
		}
	}
}


def getTimeStampStr() {
	new Date().format('yyyyMMddHHmmss')
}

def localBundleDir = project.properties['liferay.workspace.home.dir']
ext.productVersion = project.properties['product.version'] ?: "1.0.0"
ext.productName = project.properties['product.name'] ?: project.name

String distLocalMode = project.properties["distLocalMode"]

if (distLocalMode == null && project.properties['nexus.release.mode'] == "true") {
	distLocalMode = "false"
}
else if (distLocalMode == null && project.properties['gitSnapshotsBranch'] == false) {
	distLocalMode = "false"
}
else if (distLocalMode == null) {
	distLocalMode = "true"
}

println "** distLocalMode = ${distLocalMode}"

/*
 * List all configurations eligible as "Distribution Profile"
 */
task listDistProfiles() {
	doLast {
		configurations.each { config ->
			if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
				return;
			}

			def taskName = config.name.capitalize()
			println config.name + " ->  tar$taskName , zip$taskName , deploy$taskName"
		}
	}
}

/*
 * Describe "Distribution Profile" in a way usable in build-dist.gradle
 * as dependency
 * TODO: Find a way to resolve bom versions
 */
task showDistProfiles() {
	if (distLocalMode == "true") {
		dependsOn configurations.archives.artifacts
	}

	doLast {
		configurations.each { config ->
			if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
				return;
			}

			println "----"
			println "Distribution Profile: ${archivesBaseName}-${productVersion} ${config.name} ${project.property('registrySuffix')}"
			println ""
			println "dependencies {"

			config.getDependencies().each{ dep ->
				if (dep instanceof ExternalDependency) {
					ProjectDependency projectDependency = dep as ProjectDependency

					if (projectDependency.version != null) {
						println "	compileOnly group:'${projectDependency.group}', name:'${projectDependency.name}', version:'${projectDependency.version}'"
					}
					else {
						println "	compileOnly group:'${projectDependency.group}', name:'${projectDependency.name}'"
					}
				}
				else if (dep instanceof ProjectDependency) {
					ProjectDependency projectDependency = dep as ProjectDependency

					Project prj = projectDependency.getDependencyProject()

					String archivesBaseName = prj.properties["archivesBaseName"]
					String targetVersion = projectDependency.version

					if (!isChangedProject(prj.path) && prj.hasProperty('originalVersion')) {
						targetVersion = prj.property('originalVersion')
					}

					println "	compileOnly group:'${projectDependency.group}', name:'${archivesBaseName}', version:'${targetVersion}'"
				}
				else {
					println "	//??? ${dep}"
				}
			}

			println "}"
			println ""
		}
	}
}

/*
 * Describe "Distribution Profile" in a way usable to materialize a
 * local maven repository
 */
task showDistInstall() {
	if (distLocalMode == "true") {
		dependsOn configurations.archives.artifacts
	}

	doLast {
		configurations.each { config ->
			if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
				return;
			}

			println "----"
			println "Distribution Profile: ${archivesBaseName}-${productVersion} ${config.name} ${project.property('registrySuffix')}"
			println ""

			def taskName = config.name.capitalize()

			config.getDependencies().each{ dep ->
				if (dep instanceof ExternalDependency) {
					// Skip.
				}
				else if (dep instanceof ProjectDependency) {
					ProjectDependency projectDependency = dep as ProjectDependency

					Project prj = projectDependency.getDependencyProject()

					String packaging = "jar"
					String archivesBaseName = prj.properties["archivesBaseName"]
					String targetVersion = projectDependency.version

					if (!isChangedProject(prj.path) && prj.hasProperty('originalVersion')) {
						targetVersion = prj.property('originalVersion')
					}

					if (prj.tasks.findByName("war")) {
						packaging = "war"
					}

					println "mvn install:install-file -Dfile='libs/${archivesBaseName}-${targetVersion}.${packaging}' -DgroupId='${prj.group}' -DartifactId='${archivesBaseName}' -Dversion='${targetVersion}' -Dpackaging=${packaging}"
				}
				else {
					println "	//??? ${dep}"
				}
			}

			println ""
		}
	}
}

/*
 * This task is useful on local developer environment to deploy project
 * core element on local Liferay.
 */
task deployCoreDependencies(type: Copy) {
	into "${localBundleDir}/deploy"
	from configurations.distCoreLibs
}

def tarProfiles = []
def zipProfiles = []

def distDependencySpec(boolean allowExternal, boolean allowProject) {
	return new Spec<Dependency>() {
		boolean isSatisfiedBy(Dependency element) {
			if (element instanceof ExternalDependency && allowExternal) {
				return true
			}
			else if (element instanceof ProjectDependency && allowProject) {
				return true
			}
			else {
				return false
			}
		}
	}
}

task buildDistDepsMap() {
	doLast {
		configurations.each { config ->
			if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
				return;
			}

			Configuration clone = null;

			if (distLocalMode == "true" && project.properties['changesMode'] == false) {
				clone = config.copy()

				// Ensure clone has custom BoMs
				if (productBoms.size() > 0) {
					productBoms.each {
						clone.dependencies.add(dependencies.platform("${it}"))
					}
				}
			}
			else {
				clone = config.copy(distDependencySpec(true, false))

				// Ensure clone has custom BoMs
				if (productBoms.size() > 0) {
					productBoms.each {
						clone.dependencies.add(dependencies.platform("${it}"))
					}
				}

				config.dependencies.each { dep ->
					if (dep instanceof ExternalDependency) {
						// Already included
					}
					else if (dep instanceof ProjectDependency) {
						ProjectDependency projectDependency = dep as ProjectDependency

						Project prj = projectDependency.getDependencyProject()

						//println "${prj.path}:${prj.properties['version']}:${prj.properties['originalVersion']}"

						if (isChangedProject(prj.path)) {
							//println " has changes use local "
							clone.dependencies.add(projectDependency)
						}
						else {
							String archivesBaseName = prj.properties["archivesBaseName"]

							clone.dependencies.add(dependencies.create("${projectDependency.group}:${archivesBaseName}:${prj.properties['originalVersion']}"))
						}
					}
					else {
						println "??? ${dep}"
					}
				}
			}

			def taskName = config.name.capitalize()

			Task zipTargetTask = tasks.getByName("zip$taskName")

			zipTargetTask.into("libs") {
				from clone
			}

			Task tarTargetTask = tasks.getByName("tar$taskName")

			tarTargetTask.into("libs") {
				from clone
			}
		}
	}
}


configurations.each { config ->
	if (!config.name.startsWith("dist") && !config.name.startsWith("feature")) {
		return;
	}

	//println config.name + ":" + config.visible

	def taskName = config.name.capitalize()

	tarProfiles.add("tar$taskName")
	zipProfiles.add("zip$taskName")

	task "tar$taskName"(type: Tar) {
		description = "Build a tarball of runtime artifacts"
		appendix = config.name
		classifier = getTimeStampStr()
		duplicatesStrategy = DuplicatesStrategy.EXCLUDE
		compression = Compression.GZIP
		version = productVersion

		dependsOn buildDistDepsMap
	}

	task "zip$taskName"(type: Zip) {
		description = "Build a zip of runtime artifacts"
		appendix = config.name
		classifier = getTimeStampStr()
		duplicatesStrategy = DuplicatesStrategy.EXCLUDE
		version = productVersion

		dependsOn buildDistDepsMap
	}

	task "deploy$taskName"(type: Copy) {
		description = "Deploy dependencies on local Liferay"

		Configuration clone = config.copy(distDependencySpec(true, false));

		config.getDependencies().each{ dep ->
			if (dep instanceof ProjectDependency) {
				ProjectDependency projectDependency = dep as ProjectDependency
				Project prj = projectDependency.getDependencyProject()

				dependsOn "${prj.path}:deploy"
			}
		}

		into "${localBundleDir}/deploy"
		from clone
	}

	Task zipTargetTask = tasks.getByName("zip$taskName")
	Task tarTargetTask = tasks.getByName("tar$taskName")

	if (distLocalMode == "true" && project.properties['changesMode'] == true) {
		config.dependencies.each { dep ->
			if (dep instanceof ProjectDependency) {
				ProjectDependency projectDependency = dep as ProjectDependency

				Project prj = projectDependency.getDependencyProject()

				if (isChangedProject(prj.path)) {
					zipTargetTask.dependsOn(prj.path + ":packageForDist")
				}
			}
		}
	}

}

task tarDistAll() {
	dependsOn tarProfiles
}

task zipDistAll() {
	dependsOn zipProfiles
}

/*
 * List projects which artifact isn't already published to Maven Repository
 */
task checkPubStatus() {

	doLast {
		def prjMap = [:]

		// Create a configuration with all the projects

		Configuration config = configurations.create("publicationStatus")

		config.transitive = false
		config.visible = false

		rootProject.subprojects.each { prj ->
			if (!prj.subprojects.empty) return
			if (prj.path.startsWith(":bom") || prj.path.startsWith(":plugins-sdk")) return

			String archivesBaseName = prj.properties["archivesBaseName"]
			String targetVersion = prj.properties["version"]

			if (!isChangedProject(prj.path) && prj.hasProperty('originalVersion')) {
				targetVersion = prj.property('originalVersion')
			}

			def prjId = "${prj.group}:${archivesBaseName}:${targetVersion}"

			logger.debug("SMC ${prj} : ${prjId}")

			config.dependencies.add(dependencies.create("${prjId}"))

			prjMap["${prjId}"] = prj
		}

		//deltaPublication.resolve()

		def resolved = config.getResolvedConfiguration()

		println "Has errors = ${resolved.hasError()}"

		println "INFO: modules with changes but same version is already published"

		resolved.getLenientConfiguration().getFirstLevelModuleDependencies().each{ dep ->
			def prjId = "${dep.moduleGroup}:${dep.moduleName}:${dep.moduleVersion}"

			Project prj = prjMap["${prjId}"]

			if (prj != null) {
				if (isChangedProject(prj.path)) {
					logger.debug("SMC ${prjId} -> 	${prj.path}")
					println "	${prj.path}"
				}
			}
			else {
				println "	not found ${prjId}"
			}
		}

		println "ERROR: modules not published"

		resolved.getLenientConfiguration().getUnresolvedModuleDependencies().each{ dep ->
			def prjId = "${dep.selector.group}:${dep.selector.name}:${dep.selector.version}"

			Project prj = prjMap["${prjId}"]

			if (prj != null) {
				logger.debug("SMC ${prjId} -> 	${prj.path}")
				println "	${prj.path}"
			}
			else {
				println "	not found ${prjId}"
			}
		}

	}
}
